separateAo=true

oldLighting=false

underwaterOverlay=false

blend.gbuffers_basic=off
blend.gbuffers_block=off
blend.gbuffers_terrain=off
blend.gbuffers_entities=off
blend.gbuffers_hand=off
blend.gbuffers_hand_water=off
blend.gbuffers_water=off
blend.gbuffers_spidereyes=off
blend.gbuffers_textured=off
blend.gbuffers_skybasic=off
blend.gbuffers_skytextured=off
blend.gbuffers_textured_lit=off
blend.gbuffers_clouds=off
blend.shadow=off

uniform.float.timePi=frameTimeCounter * pi

variable.float.sunVectorNorm = 1.0 / sqrt((sunPosition.x * sunPosition.x) + (sunPosition.y * sunPosition.y) + (sunPosition.z * sunPosition.z))
uniform.vec3.sunVectorView = vec3(sunPosition.x * sunVectorNorm, sunPosition.y * sunVectorNorm, sunPosition.z * sunVectorNorm)
variable.float.sunVectorX = gbufferModelViewInverse.0.0 * sunPosition.x + gbufferModelViewInverse.1.0 * sunPosition.y + gbufferModelViewInverse.2.0 * sunPosition.z
variable.float.sunVectorY = gbufferModelViewInverse.0.1 * sunPosition.x + gbufferModelViewInverse.1.1 * sunPosition.y + gbufferModelViewInverse.2.1 * sunPosition.z
variable.float.sunVectorZ = gbufferModelViewInverse.0.2 * sunPosition.x + gbufferModelViewInverse.1.2 * sunPosition.y + gbufferModelViewInverse.2.2 * sunPosition.z
uniform.vec3.sun_vector = vec3(sunVectorX * sunVectorNorm, sunVectorY * sunVectorNorm, sunVectorZ * sunVectorNorm)

variable.float.moonVectorNorm = 1.0 / sqrt((moonPosition.x * moonPosition.x) + (moonPosition.y * moonPosition.y) + (moonPosition.z * moonPosition.z))
uniform.vec3.moonVectorView = vec3(moonPosition.x * moonVectorNorm, moonPosition.y * moonVectorNorm, moonPosition.z * moonVectorNorm)
variable.float.moonVectorX = gbufferModelViewInverse.0.0 * moonPosition.x + gbufferModelViewInverse.1.0 * moonPosition.y + gbufferModelViewInverse.2.0 * moonPosition.z
variable.float.moonVectorY = gbufferModelViewInverse.0.1 * moonPosition.x + gbufferModelViewInverse.1.1 * moonPosition.y + gbufferModelViewInverse.2.1 * moonPosition.z
variable.float.moonVectorZ = gbufferModelViewInverse.0.2 * moonPosition.x + gbufferModelViewInverse.1.2 * moonPosition.y + gbufferModelViewInverse.2.2 * moonPosition.z
uniform.vec3.moon_vector = vec3(moonVectorX * moonVectorNorm, moonVectorY * moonVectorNorm, moonVectorZ * moonVectorNorm)

variable.float.shadowLightVectorNorm = 1.0 / sqrt((shadowLightPosition.x * shadowLightPosition.x) + (shadowLightPosition.y * shadowLightPosition.y) + (shadowLightPosition.z * shadowLightPosition.z))
uniform.vec3.shadowLightVectorView = vec3(shadowLightPosition.x * moonVectorNorm, shadowLightPosition.y * moonVectorNorm, shadowLightPosition.z * moonVectorNorm)
variable.float.shadowLightVectorX = gbufferModelViewInverse.0.0 * shadowLightPosition.x + gbufferModelViewInverse.1.0 * shadowLightPosition.y + gbufferModelViewInverse.2.0 * shadowLightPosition.z
variable.float.shadowLightVectorY = gbufferModelViewInverse.0.1 * shadowLightPosition.x + gbufferModelViewInverse.1.1 * shadowLightPosition.y + gbufferModelViewInverse.2.1 * shadowLightPosition.z
variable.float.shadowLightVectorZ = gbufferModelViewInverse.0.2 * shadowLightPosition.x + gbufferModelViewInverse.1.2 * shadowLightPosition.y + gbufferModelViewInverse.2.2 * shadowLightPosition.z
uniform.vec3.shadow_light_vector = vec3(shadowLightVectorX * shadowLightVectorNorm, shadowLightVectorY * shadowLightVectorNorm, shadowLightVectorZ * shadowLightVectorNorm)

uniform.vec3.up_vector = vec3(0.0, 1.0, 0.0)

uniform.vec2.view_pixel_size=vec2(1.0 / viewWidth, 1.0 / viewHeight)
uniform.vec2.view_size=vec2(viewWidth, viewHeight)

screen=[Tonemapping] BlocklightTemperature
    screen.Tonemapping=Tonemap [Reinhard] [ACES]
        screen.Reinhard=ReinhardMode
        screen.ACES=ACES_Slope ACES_Toe ACES_Shoulder ACES_BlackClip ACES_WhiteClip ACES_BlueCorrection ACES_GamutExpansion